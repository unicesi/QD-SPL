<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Classic UML Tutorial</title><link rel="stylesheet" href="../book.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.72.0"><link rel="start" href="index.html" title="openArchitectureWare User Guide"><link rel="up" href="reference.html" title="Part&nbsp;II.&nbsp;Reference"><link rel="prev" href="classic_reference.html" title="&#34;Classic&#34; Reference"><link rel="next" href="samples.html" title="Part&nbsp;III.&nbsp;Samples"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="umlclassic_tutorial"></a>Classic UML Tutorial</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="umlclassic_tutorial.html#umlclassic_introduction">Introduction</a></span></dt><dt><span class="section"><a href="umlclassic_tutorial.html#umlclassic_installation">Installing the sample</a></span></dt><dt><span class="section"><a href="umlclassic_tutorial.html#umlclassic_example_overview">Example overview</a></span></dt><dt><span class="section"><a href="umlclassic_tutorial.html#umlclassic_project_setup">Setting up the project</a></span></dt><dt><span class="section"><a href="umlclassic_tutorial.html#umlclassic_defining_dependencies">Defining Dependencies</a></span></dt><dt><span class="section"><a href="umlclassic_tutorial.html#umlclassic_create_source_folders">Create source folders</a></span></dt><dt><span class="section"><a href="umlclassic_tutorial.html#umlclassic_create_model">Create the model</a></span></dt><dt><span class="section"><a href="umlclassic_tutorial.html#umlclassic_defining_metamodel">Defining the metamodel</a></span></dt><dt><span class="section"><a href="umlclassic_tutorial.html#umlclassic_log4j">Log4j configuration</a></span></dt><dt><span class="section"><a href="umlclassic_tutorial.html#umlclassic_create_generator">Creating the generator workflow and the first template</a></span></dt><dt><span class="section"><a href="umlclassic_tutorial.html#umlclassic_execute_workflow">Execute the workflow</a></span></dt><dt><span class="section"><a href="umlclassic_tutorial.html#umlclassic_looping_model">Looping through the model</a></span></dt><dt><span class="section"><a href="umlclassic_tutorial.html#umlclassic_create_template">Creating a template for JavaBeans</a></span></dt><dt><span class="section"><a href="umlclassic_tutorial.html#umlclassic_calling_javabean_template">Calling the <code class="methodname">JavaBean</code> template from
		<code class="filename">Root.xpt</code></a></span></dt><dt><span class="section"><a href="umlclassic_tutorial.html#umlclassic_first_generated_code">The first generated code</a></span></dt><dt><span class="section"><a href="umlclassic_tutorial.html#umlclassic_property_declaration">Defining property declarations and accessor methods</a></span></dt><dt><span class="section"><a href="umlclassic_tutorial.html#umlclassic_using_extensions">Using Extensions</a></span></dt><dt><span class="section"><a href="umlclassic_tutorial.html#umlclassic_associations">Working with associations</a></span></dt><dt><span class="section"><a href="umlclassic_tutorial.html#umlclassic_constraint_checking">Constraint Checking</a></span></dt><dt><span class="section"><a href="umlclassic_tutorial.html#umlclassic_further_development">Further development of this tutorial</a></span></dt></dl></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="umlclassic_introduction"></a>Introduction</h2></div></div></div><p>This example shows the usage of openArchitectureWare 4 with
		integration of an UML tool. In openArchitectureWare 4, we call this
		"Classic" style, as the underlying metamodel has to be the "Classic" UML
		metamodel that was introduced by oAW 3. For the example, Magic Draw 11.5
		Community Edition is used, but the example can easily be adapted to any
		supported UML tool. It is strongly recommended to work through this
		tutorial with MagicDraw in order to minimize environmental
		problems!</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="umlclassic_installation"></a>Installing the sample</h2></div></div></div><p>Make sure that you installed the openArchitectureWare feature
		properly in your Eclipse environment.</p><p>openArchitectureWare depends on EMF, so check that you have
		installed it. If you need further information on oAW installation please
		look at <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.openarchitectureware.org/staticpages/index.php/documentation." target="_top">http://www.openarchitectureware.org/staticpages/index.php/documentation.</a></p><p>Instead of working through this tutorial, you can also install the
		packaged example by downloading the
		<code class="filename">oaw-samples-classic-uml-4.x.x</code> package. It contains
		one Eclipse project, which you have to import into your workspace. To make
		the projects compile and run, you may have to define to use the
		<span class="emphasis"><em>oAW-Classic Metamodel</em></span> in the project
		properties:</p><div class="figure"><a name="umlclassic_metamodel_configuration"></a><p class="title"><b>Figure&nbsp;56.&nbsp;Configure oAW-Classic Metamodel</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/55_umlClassicExample/01_metamodelConfiguration.jpg" alt="Configure oAW-Classic Metamodel"></div></div></div><br class="figure-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="umlclassic_example_overview"></a>Example overview</h2></div></div></div><p>The purpose of this tutorial is to demonstrate the very simplest way
		to use oAW4 in combination with an (non EMF UML2 capable) UML tool to
		create code from a model that contains some classes. The project is really
		simple, so it is the right place to start when you are new to
		openArchitectureWare 4 and want to use UML tools like MagicDraw, Poseidon,
		Rational Rose etc.</p><p>In this example, we want to generate code from this model:</p><div class="figure"><a name="umlclassic_example_model"></a><p class="title"><b>Figure&nbsp;57.&nbsp;Example Model</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/55_umlClassicExample/02_model.jpg" alt="Example Model"></div></div></div><br class="figure-break"><p>As a result, we want to create some JavaBean style classes which
		have properties with getter/setter methods.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="umlclassic_project_setup"></a>Setting up the project</h2></div></div></div><p>Create a new Java Project called
		<code class="filename">oaw4.demo.classic.uml</code> and select the option to create
		seperate source and output folders.</p><div class="figure"><a name="umlclassic_creating_tutorial_project"></a><p class="title"><b>Figure&nbsp;58.&nbsp;Creating the tutorial project</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/55_umlClassicExample/03_create_project.jpg" alt="Creating the tutorial project"></div></div></div><br class="figure-break"><p>Afterwards, select from the context menu <span class="guimenu">PDE tools</span> &#8594; <span class="guisubmenu">Convert Projects to Plug-in Projects</span>, since we want to define our dependencies via Eclipse
		Plug-In dependencies.</p><p>Alternatively, you could create a Plug-In project instead of these
		both steps.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="umlclassic_defining_dependencies"></a>Defining Dependencies</h2></div></div></div><p>In the new project, there is now a
		<code class="filename">META-INF/MANIFEST.MF</code>. Open it, go to the Dependencies
		page and add the following dependencies:</p><div class="figure"><a name="umlclassic_plugin_dependencies"></a><p class="title"><b>Figure&nbsp;59.&nbsp;Defining plug-in dependencies for oAW Classic</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/55_umlClassicExample/04_dependencies.png" alt="Defining plug-in dependencies for oAW Classic"></div></div></div><br class="figure-break"><div class="itemizedlist"><ul type="disc"><li><code class="classname">org.openarchitectureware.classic.umlMetamodel</code>

					 : The classic UML metamodel classes
				</li><li><code class="classname">org.openarchitectureware.classic.core</code>

					 : Framework classes for oAW classic
				</li><li><code class="classname">org.openarchitectureware.classic.workflow</code>

					 : oAW classic workflow components and cartridges
				</li><li><code class="classname">org.openarchitectureware.classic.xmiInstantiator</code>

					 : Parser component for UML tools
				</li><li><code class="classname">org.openarchitectureware.classic.libraries</code>

					 : Required 3rd party libraries
				</li><li><code class="classname">org.openarchitectureware.core.xpand2</code>

					 : The Xpand template engine
				</li><li><code class="classname">org.openarchitectureware.core.expressions</code>

					 : oAW language Check for defining constraints
				</li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="umlclassic_create_source_folders"></a>Create source folders</h2></div></div></div><p>Create two folders <code class="filename">model</code> and
		<code class="filename">templates</code> in the project root (not in
		<code class="filename">src</code>!) and add this folders as classpath folders in
		the project properties dialog, Libraries tab. By doing this, the model and
		the templates can be found in the classpath of the project without placing
		the files in the source folder.</p><div class="figure"><a name="umlclassic_creating_source_folders"></a><p class="title"><b>Figure&nbsp;60.&nbsp;Creating source folders</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/55_umlClassicExample/05_classpath_folders.jpg" alt="Creating source folders"></div></div></div><br class="figure-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="umlclassic_create_model"></a>Create the model</h2></div></div></div><p>This section explains how to create the model from scratch using
		MagicDraw 10/11. If you are using another UML tool, this is a guideline to
		create the model, but the tool can differ in some details. You can skip
		this section if you have MagicDraw, downloaded the sample project and use
		the model from the sample project.</p><p>Start your UML Tool and create the model from the screenshot above.
		You have to create the Stereotypes <code class="classname">Entity</code> and
		<code class="classname">Key</code>.</p><p>To define the model above follow these steps: </p><div class="orderedlist"><ol type="1"><li>
					 Create the stereotype

					<code class="classname">Entity</code>

					 with base class

					<code class="classname">Class</code>

					 .
				</li><li>
					 Create the stereotype

					<code class="classname">Key</code>

					 with base class

					<code class="classname">Property</code>

					 .
				</li><li>
					 Create the stereotype

					<code class="classname">DAO</code>

					 with base class

					<code class="classname">Class</code>

					 .
				</li><li>
					 Create a package structure in your project:

					<code class="classname">oaw4 / demo / classic / uml / entity</code></li><li>
					 Create a class diagramm in the package

					<code class="classname">entity</code></li><li>
					 Create a class

					<code class="classname">Author</code><div class="orderedlist"><ol type="a"><li>Assign the stereotype
						<code class="classname">Entity</code></li><li>Create an attribute <code class="methodname">id</code> of type
						<code class="classname">String</code>. Please select for String the
						datatype from your model, <span class="emphasis"><em>not from UML Standard
						Profile</em></span>! Assign the stereotype
						<code class="classname">Key</code> for this attribute.</li><li>Create an attribute <code class="methodname">name</code> of
						type <code class="classname">String</code>.</li></ol></div></li><li>
					 Create the class

					<code class="classname">Book</code>

					 with stereotype

					<code class="classname">Entity</code>

					 . The

					<code class="classname">Key</code>

					 attribute is

					<code class="methodname">isbn</code>

					 of type

					<code class="classname">String</code>

					 . The second attribute is the

					<code class="methodname">title</code>

					 .
				</li><li>
					 Draw an association between these two classes.

					<div class="orderedlist"><ol type="a"><li>The association end at class
						<code class="classname">Author</code> is named
						<code class="methodname">author</code>, is navigable and the multiplicity
						is <span class="emphasis"><em>1..*</em></span>.</li><li>The other association end is
						<code class="methodname">writtenBook</code> with multiplicity
						<span class="emphasis"><em>0..*</em></span> and is navigable.</li></ol></div></li><li>
					 Create the class

					<code class="classname">Copy</code>

					 of stereotype

					<code class="classname">Entity</code><div class="orderedlist"><ol type="a"><li>The <code class="classname">Key</code> attribute is
						<code class="methodname">inventoryNumber</code> of type
						<code class="classname">String</code>.</li><li>Add attribute <code class="methodname">location</code> of type
						<code class="classname">String</code>.</li></ol></div></li><li>
					 Draw a

					<span class="emphasis"><em>directed</em></span>

					 association from

					<code class="classname">Copy</code>

					 to

					<code class="classname">Book</code><div class="orderedlist"><ol type="a"><li>The association end at class <code class="classname">Book</code>
						is named <code class="methodname">book</code>, is navigable, with
						multplicity <span class="emphasis"><em>1</em></span>.</li><li>The opposite end at <code class="classname">Copy</code> is
						unnamed, not navigable and multiplicity
						<span class="emphasis"><em>0..*</em></span></li></ol></div></li><li>
					 Create the class

					<code class="classname">Library</code>

					 of stereotype

					<code class="classname">Entity</code><div class="orderedlist"><ol type="a"><li>The <code class="classname">Key</code> attribute is
						<code class="methodname">id</code> of type
						<code class="classname">String</code>.</li><li>The library has a <code class="classname">String</code>
						attribute <code class="methodname">name</code></li></ol></div></li><li>
					 Draw an association from

					<code class="classname">Library</code>

					 to

					<code class="classname">Copy</code><div class="orderedlist"><ol type="a"><li>The association end at class
						<code class="classname">Library</code> is named
						<code class="methodname">owner</code>, is navigable, the multiplicity is
						<span class="emphasis"><em>1</em></span>.</li><li>The association end at class <code class="classname">Book</code>
						is named <code class="methodname">ownedBook</code>, is navigable and the
						multiplicity is <span class="emphasis"><em>1..*</em></span>.</li></ol></div></li></ol></div><p>Save your model packed format in the model folder of your project
		and give the file the name
		<code class="filename">AuthorBookExampleMD11.mdzip</code>. The tool adapter will
		automatically recognize that it is zipped and read the appropriate ZIP
		entry.</p><p>Create a subfolder <code class="filename">model/md11</code>. From the
		<code class="filename">profiles</code> directory of your MagicDraw installation
		copy the <code class="filename">UML_Standard_Profile.xml</code> to there.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="umlclassic_defining_metamodel"></a>Defining the metamodel</h2></div></div></div><p>Models are instances of a <span class="emphasis"><em>Metamodel</em></span>. In order
		to get openArchitectureWare to do something useful it needs to know the
		used metamodel. Using oAW "Classic" the metamodel is implemented by
		metaclasses. In UML, they are represented in the model by
		stereotypes.</p><p>The recently defined model already uses the stereotypes
		<code class="classname">DAO</code>, <code class="classname">Entity</code> and
		<code class="classname">Key</code>. Entities are some kind of business objects,
		which have some attributes. They are represented in UML as classes.
		Exactly one attribute is a special one: a <code class="classname">Key</code>
		attribute. <code class="classname">DAOs</code> are classes which manage
		<code class="classname">Entities</code>. We want to express this relationship by
		using a dependency from <code class="classname">DAO</code>&nbsp;to
		<code class="classname">Entity</code> in our model.</p><p>In UML, this metamodel looks like this:</p><div class="figure"><a name="umlclassic_tutorial_metamodel"></a><p class="title"><b>Figure&nbsp;61.&nbsp;Tutorial Metamodel</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/55_umlClassicExample/06_metamodel.jpg" alt="Tutorial Metamodel"></div></div></div><br class="figure-break"><p>We have to provide the metaclasses that make up our DSL. The base
		metaclasses <code class="classname">Class</code> and
		<code class="classname">Attribute</code> are provided by openArchitectureWare
		within the package <code class="filename">org.openarchitectureware.meta.uml</code>
		and its subpackages.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="umlclassic_defining_metaclasses"></a>Defining the metaclasses</h3></div></div></div><p>Create a package <code class="filename">oaw4.demo.classic.uml.meta</code>.
			This package will contain our metaclasses which realize the UML profile
			we want to use. As you can see from the model above we use the
			Stereotypes <code class="classname">Entity</code>, <code class="classname">Key</code>
			and <code class="classname">DAO</code>. For these Stereotypes we need
			metaclasses.</p><p>Metaclasses are derived from UML metaclasses. oAW4 provides
			implementation classes for UML metaclasses. For example, an
			<code class="classname">Entity</code> is represented by classes, so, the right
			metaclass to extend is <code class="classname">Class</code>, while
			<code class="classname">Key</code>s are a specialization from
			<code class="classname">Attribute</code>.</p><p>In the simplest case, you will only have to create the classes
			<code class="classname">Entity</code>, <code class="classname">Key</code> and
			<code class="classname">DAO</code> and derive them from the base metaclasses
			<code class="classname">Class</code> and <code class="classname">Attribute</code>
			defined in package
			<code class="filename">org.openarchitecture.meta.uml.classifier</code>:</p><pre class="programlisting">package oaw4.demo.classic.uml.meta;

public class Entity extends org.openarchitectureware.meta.uml.classifier.Class {
	 // nothing to do in the simplest case
}</pre><pre class="programlisting">package oaw4.demo.classic.uml.meta;

public class Key extends org.openarchitectureware.meta.uml.classifier.Attribute {
}</pre><pre class="programlisting">package oaw4.demo.classic.uml.meta;

public class DAO extends org.openarchitectureware.meta.uml.classifier.Class {
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="umlclassic_metamappings"></a>Metamappings</h3></div></div></div><p>By now, the generator will not know that the stereotype
			<code class="classname">&lt;&lt;Entity&gt;&gt;</code> has to be mapped to the
			metaclass <code class="classname">oaw4.demo.classic.uml.meta.Entity</code>. By
			default these elements are mapped to their UML base classes, in case of
			<code class="classname">Entity</code> this is
			<code class="classname">Class</code>.</p><p>To map stereotypes to metaclasses a xml file has to be created,
			called the <span class="emphasis"><em>metamapping file</em></span>.</p><p>Create the file <code class="filename">metamappings.xml</code> in your
			source folder:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE MetaMap SYSTEM "http://www.openarchitectureware.org/dtds/metamap.dtd"&gt;

&lt;MetaMap&gt;
	 &lt;Mapping&gt;
			&lt;Map&gt;Entity&lt;/Map&gt;
			&lt;To&gt;oaw4.demo.classic.uml.meta.Entity&lt;/To&gt;
	 &lt;/Mapping&gt;
	 &lt;Mapping&gt;
			&lt;Map&gt;DAO&lt;/Map&gt;
			&lt;To&gt;oaw4.demo.classic.uml.meta.DAO&lt;/To&gt;
	 &lt;/Mapping&gt;
	 &lt;Mapping&gt;
			&lt;Map&gt;Key&lt;/Map&gt;
			&lt;To&gt;oaw4.demo.classic.uml.meta.Key&lt;/To&gt;
	 &lt;/Mapping&gt;
&lt;/MetaMap&gt;
</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="umlclassic_log4j"></a>Log4j configuration</h2></div></div></div><p>Later when running the generator you would like to see some output
		messages. Therefore you have to define a
		<code class="filename">log4j.properties</code>. Create this file in the source
		folder:</p><pre class="programlisting"># Set root logger level to INFO and its only appender to A1.
log4j.rootLogger=INFO, A1

# A1 is set to be a ConsoleAppender.
log4j.appender.A1=org.apache.log4j.ConsoleAppender

# A1 uses PatternLayout.
log4j.appender.A1.layout=org.apache.log4j.PatternLayout
log4j.appender.A1.layout.ConversionPattern=%-4r %-5p %m%n
</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="umlclassic_create_generator"></a>Creating the generator workflow and the first template</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="umlclassic_workflow"></a>The workflow script</h3></div></div></div><p>The next step is to create a workflow script. The workflow has to
			accomplish the following tasks: </p><div class="itemizedlist"><ul type="disc"><li>
						 Initialize the environment for using the "classic" metamodel
					</li><li>
						 Parse the tool-specific xmi file and instantiate the metamodel
					</li><li>
						 Initialize all instantiated elements
					</li><li>
						 Run the generator to create code
					</li><li>
						 Tear-down: Print messages collected through the generator run
					</li></ul></div><p>For all these tasks, pre-defined workflow-scripts and components
			can be included in the workflow. The following workflow script does all
			these tasks and should fit for the first steps. Later on, you may need
			to customize the workflow script to integrate further components like
			model modifiers. Therefore, the script itself is not bundled as a
			cartridge.</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;workflow&gt;
	 &lt;property file="workflow.properties"/&gt;

	 &lt;cartridge file="org/openarchitectureware/workflow/oawclassic/classicstart.oaw"&gt;
			&lt;metaEnvironmentSlot value="me"/&gt;
			&lt;instantiatorEnvironmentSlot value="ie"/&gt;
	 &lt;/cartridge&gt;

	 &lt;component class="org.openarchitectureware.core.frontends.xmi.workflow.XMIInstantiator"&gt;
			&lt;instantiatorEnvironmentSlot value="ie"/&gt;
			&lt;modelFile value="${model.xmi}"/&gt;
			&lt;xmlMapFile value="${toolMappingFile}"/&gt;
			&lt;metaMapFile value="${metaMapFile}"/&gt;
			&lt;toolAdapterClassname value="${toolAdapterClassname}"/&gt;
			&lt;moduleFile value="${moduleFile}"/&gt;
			&lt;outputSlot value="model"/&gt;
	 &lt;/component&gt;

	 &lt;cartridge file="org/openarchitectureware/workflow/oawclassic/classicinit.oaw"&gt;
			&lt;metaEnvironmentSlot value="me"/&gt;
	 &lt;/cartridge&gt;

	 &lt;component id="dirCleaner"
			class="org.openarchitectureware.workflow.common.DirectoryCleaner"&gt;
			&lt;directories value="${srcGenPath}"/&gt;
	 &lt;/component&gt;

	 &lt;component id="generator" class="org.openarchitectureware.xpand2.Generator"&gt;
			&lt;metaModel class="org.openarchitectureware.type.impl.java.JavaMetaModel"&gt;
				 &lt;typeStrategy
						class="org.openarchitectureware.type.impl.oawclassic.OAWClassicStrategy"
						convertPropertiesToLowerCase="false"/&gt;
			&lt;/metaModel&gt;
			&lt;expand value="Root::Root FOREACH me.getElements('Model')"/&gt;
			&lt;genPath value="${srcGenPath}/"/&gt;
			&lt;srcPath value="${srcGenPath}/"/&gt;
			&lt;beautifier class="org.openarchitectureware.xpand2.output.JavaBeautifier"/&gt;
			&lt;beautifier class="org.openarchitectureware.xpand2.output.XmlBeautifier"/&gt;
			&lt;fileEncoding value="ISO-8859-1"/&gt;
	 &lt;/component&gt;

	 &lt;cartridge file="org/openarchitectureware/workflow/oawclassic/classicfinish.oaw"&gt;
			&lt;instantiatorEnvironmentSlot value="ie"/&gt;
			&lt;dumpfile value="${dumpfile}"/&gt;
	 &lt;/cartridge&gt;

&lt;/workflow&gt;
</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="umlclassic_workflow_properties"></a>Workflow Properties</h3></div></div></div><p>The workflow includes a properties file, in which the concrete
			configuration is stored. Create the file
			<code class="filename">workflow.properties</code> like this:</p><pre class="programlisting"># Note: all paths must be found in the classpath!
# the metamappings file
metaMapFile = metamappings.xml

# model.xmi: name of the XMI export
# toolMappingFile: tool mapping file to use
# toolAdapterClassname: tool adapter implementation
# moduleFile: profile files

# MagicDraw 10
model.xmi = AuthorBookExampleMD10.mdzip
toolMappingFile = magicdraw_xmi21_all.xml
toolAdapterClassname =
	 org.openarchitectureware.core.frontends.xmi.toolsupport.uml.magicdraw.MagicDrawAdapter21
moduleFile =
	 magicdraw/md10/UML_Standard_Profile.xml

#model.xmi = AuthorBookExampleMD11.mdzip
#toolMappingFile = magicdraw_xmi21_all.xml
#toolAdapterClassname =
	 org.openarchitectureware.core.frontends.xmi.toolsupport.uml.magicdraw.MagicDrawAdapter21
#moduleFile = magicdraw/md11/UML_Standard_Profile.xml

# path to create the generated output to
srcGenPath = src-gen
# path where the dump file is created
dumpfile = bin/dump
</pre><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="umlclassic_setup_for_other_tools"></a>Setting up for use with other UML tools</h4></div></div></div><p>This configuration file is designed for use with MagicDraw.
				Other UML tools can be easily configured by changing the properties
				<em class="parameter"><code>model.xmi</code></em>,
				<em class="parameter"><code>toolAdapterClassname</code></em>,
				<em class="parameter"><code>toolMappingFile</code></em> and
				<em class="parameter"><code>moduleFile</code></em>. The property
				<em class="parameter"><code>moduleFile</code></em> specifies additional modules to load
				and merge, which is currently only evaluated by the MagicDraw
				adapter.</p><p>The existing tool adapter classes and mapping files can be found
				beneath the package </p><p>
						<code class="filename">org/openarchitectureware/core/frontends/xmi/toolsupport/uml/&lt;TOOL&gt;</code>
					</p><p>For example, to set up this project for Poseidon 4/5 the
				appropriate settings are: </p><pre class="programlisting">toolAdapterClassname =
	 org.openarchitectureware.core.frontends.xmi.toolsupport.uml.poseidon.PoseidonAdapter
toolMappingFile = poseidon40_xmi12_all.xml</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="umlclassic_create_root_template"></a>Create the root template</h3></div></div></div><p>In the workflow the generator has been configured to start with
			the this definition:</p><pre class="programlisting">&lt;expand value="Root::Root FOREACH me.getElements('Model')"/&gt;</pre><p>This means that the generator will look for a template file
			<code class="filename">Root.xpt</code> in the classpath where a definition named
			<code class="classname">Root</code> is found for all elements that are selected
			by the expression <code class="methodname">me.getElements('Model')</code>. In
			case of UML models there exists solely one element of type
			<code class="classname">Model</code> that will be selected.</p><p>Now, create the file Root.xpt in the templates folder. Remember:
			We have configured our Eclipse project that the folder templates is a
			classpath folder. You will see that the new file is recognized as an oAW
			template file, as it has a template file icon:</p><div class="mediaobject"><img src="images/55_umlClassicExample/07_rootxpt.jpg"></div><p>For the beginning the template will be simple:</p><pre class="programlisting">&laquo;IMPORT org::openarchitectureware::core::meta::core&raquo;

&laquo;DEFINE Root FOR Model&raquo;
&laquo;ENDDEFINE&raquo;</pre><p>This template contains only an empty definition for Model
			elements. The namespace of the <code class="classname">Model</code> metaclass
			must be known for the generator, so we import the corresponding package.
			Otherwise, we would have to fully qualify <code class="classname">Model</code>.
			As you could expect, this template does not really do anything
			yet.</p><p>At this time, your project structure should look like this:</p><div class="mediaobject"><img src="images/55_umlClassicExample/08_projectstructure.jpg"></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="umlclassic_execute_workflow"></a>Execute the workflow</h2></div></div></div><p>We have not defined anything useful in our template yet. However, we
		now execute the workflow to prove that everything is right configured.
		Execute the workflow by selecting <code class="filename">workflow.oaw</code> and
		select <span class="emphasis"><em>Run As -&gt; oAW Workflow</em></span> from the context
		menu. The output should be like this:</p><pre class="programlisting">0    INFO  ----------------------------------------------------------------------------------
0    INFO  openArchitectureWare v4.3 -- (c) 2005, 2008 openarchitectureware.org and contributors
0    INFO  ----------------------------------------------------------------------------------
0    INFO  running workflow:
							C:/dev/ide/workspace/oaw-v4-projects/oaw4.demo.classic.uml/src/workflow.oaw
0    INFO
540  INFO  Starting: workflow org/openarchitectureware/workflow/oawclassic/classicstart.oaw
540  INFO  Starting: org.openarchitectureware.workflow.oawclassic.ClassicOAWSetup
561  INFO  classic oAW environment is set up;
							instantiator environment in: ie, meta environment in me
561  INFO  Starting: org.openarchitectureware.core.frontends.xmi.workflow.XMIInstantiator
561  INFO  Loading XMI from: AuthorBookExampleMD10.mdzip using map: magicdraw_xmi21_all.xml
							and metamap: metamappings.xml
571  INFO  Starting mapping instantiator ...
571  INFO
581  INFO  Parsing metamap metamappings.xml ...
721  INFO  Parsing of metamap took 0.14s
721  INFO
1692 INFO  Parsing design AuthorBookExampleMD10.mdzip ...
1702 INFO  Loading model...
2163 INFO  Initializing XMI support for XMI version 2.1
2163 INFO  Scanning for referenced modules...
2183 INFO  Found reference to module 'UML_Standard_Profile.xml'
2193 INFO  Model loaded in 0.491s
2193 INFO
2193 INFO  Loading modules...
2984 INFO  Scanning for referenced modules...
3064 INFO  Modules loaded in 0.871s
3064 INFO
3074 INFO  Merging...
3114 INFO  Modules merged in 0.04s
3114 INFO
3234 INFO  Parsed design in 1.542s
3234 INFO
3234 INFO  Loading extensions...
3304 INFO  Extensions loaded in 0.07s
3304 INFO
3304 INFO  Loading design...
3314 WARN  ignoring node 65973 (ownedMember): cannot coerce to ModelElement
3314 WARN  ignoring node 66017 (ownedMember): cannot coerce to ModelElement
3314 WARN  ignoring node 66061 (ownedMember): cannot coerce to ModelElement
3314 WARN  ignoring node 66119 (ownedMember): cannot coerce to ModelElement
3314 WARN  ignoring node 68759 (ownedMember): cannot coerce to ModelElement
3314 WARN  ignoring node 70438 (ownedMember): cannot coerce to ModelElement
3324 WARN  ignoring node 65945 (ownedMember): cannot coerce to ModelElement
3334 WARN  ignoring node 65952 (ownedMember): cannot coerce to ModelElement
3334 WARN  ignoring node 65959 (ownedMember): cannot coerce to ModelElement
3334 WARN  ignoring node 65966 (ownedMember): cannot coerce to ModelElement
3405 INFO  Design loaded in 0.101s
3405 INFO
3405 INFO  Applying tool specific design modifications...
3415 INFO  Design modified in 0.01s
3415 INFO
3415 INFO  Instantiating metamodel...
3485 WARN  &lt;&lt;Model&gt;&gt; [no Name@27940994]: ignoring value for nonexisting property Documentation =
[Author:Karsten.
Created:27.02.06 08:47.
Title:.
Comment:.
]
3525 INFO  Metamodel instantiated in 0.1s
3525 INFO
3525 INFO  Instantiated design in 2.954s
3525 INFO
3525 INFO  MetaModel Summary
3525 INFO  -----------------
3525 INFO
3525 INFO  3x Association (org.openarchitectureware.meta.uml.classifier.Association)
3525 INFO  6x AssociationEnd (org.openarchitectureware.meta.uml.classifier.AssociationEnd)
3525 INFO  4x Attribute (org.openarchitectureware.meta.uml.classifier.Attribute)
3525 INFO  1x DAO (oaw4.demo.classic.uml.meta.DAO)
3525 INFO  4x Entity (oaw4.demo.classic.uml.meta.Entity)
3525 INFO  4x Key (oaw4.demo.classic.uml.meta.Key)
3525 INFO  1x Model (org.openarchitectureware.core.meta.core.Model)
3525 INFO  7x Package (org.openarchitectureware.meta.uml.classifier.Package)
3525 INFO  12x PrimitiveType (org.openarchitectureware.meta.uml.classifier.PrimitiveType)
3525 INFO
3525 INFO  Starting: workflow org/openarchitectureware/workflow/oawclassic/classicinit.oaw
3525 INFO  Starting: org.openarchitectureware.workflow.oawclassic.ModelInitializer
3525 INFO  initializing model elements (calling initializeModelElements)
3535 INFO  Starting: org.openarchitectureware.workflow.oawclassic.ModelChecker
3535 INFO  checking model elements (calling checkConstraints)
3545 INFO  Starting: org.openarchitectureware.check.CheckComponent
3765 INFO  Starting: dirCleaner [org.openarchitectureware.workflow.common.DirectoryCleaner]
3765 INFO  Cleaning C:\dev\ide\workspace\oaw-v4-projects\oaw4.demo.classic.uml\src-gen
3875 INFO  Starting: generator [org.openarchitectureware.xpand2.Generator]
3915 INFO  Starting: workflow org/openarchitectureware/workflow/oawclassic/classicfinish.oaw
3915 INFO  Starting: org.openarchitectureware.workflow.oawclassic.MessageOutput
3915 INFO  Starting: org.openarchitectureware.workflow.oawclassic.DumpWriter
3915 INFO  writing dump to: bin/dump
3925 INFO  workflow completed in 3385ms!</pre><p>Congratulations! You have just set up the whole environment to get
		openArchitectureWare running. Now, let us do the interesting stuff!</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="umlclassic_looping_model"></a>Looping through the model</h2></div></div></div><p>Later on, we want to do something with the elements contained in our
		model. A common pattern in the Root template when using UML models is to
		loop through the model to find the elements that should be expanded. A
		model is an instance of <code class="classname">Namespace</code> and all elements
		directly contained by the model can be accessed through the association
		<code class="methodname">OwnedElement</code>. The owned elements can be of
		various types: Classes, Packages, Datatypes and so on. Packages are also
		instances of <code class="classname">Namespace</code>, so they also have a
		<code class="methodname">OwnedElement</code> association.</p><p>We use the <span class="emphasis"><em><a class="indexterm" name="d0e11538"></a></em></span> feature to recursively resolve any element
		contained in the model tree. Now extend the <code class="filename">Root.xpt</code>
		template file:</p><pre class="programlisting">&laquo;IMPORT org::openarchitectureware::core::meta::core&raquo;
&laquo;IMPORT org::openarchitectureware::meta::uml::classifier&raquo;
&laquo;DEFINE Root FOR Model&raquo;
	 &laquo;EXPAND Root FOREACH OwnedElement&raquo;
&laquo;ENDDEFINE&raquo;

&laquo;DEFINE Root FOR Package&raquo;
	 &laquo;EXPAND Root FOREACH OwnedElement&raquo;
&laquo;ENDDEFINE&raquo;

&laquo;DEFINE Root FOR Object&raquo;&laquo;ENDDEFINE&raquo;</pre><p>Note, that we have added a new <code class="varname">IMPORT</code> statement,
		because the metaclass <code class="classname">Package</code> is in package
		<code class="classname">org.openarchitectureware.meta.uml.classifier</code>.</p><p>First, the definition <code class="methodname">Root</code> FOR
		<code class="classname">Model</code> will be called by the generator. This will
		call the definition named <code class="methodname">Root</code> for all elements,
		that the <code class="classname">Model</code> instance contains. Look at the last
		definition: This is a catcher for all elements that are found while
		traversing through the tree that are not of any handled type.</p><p>When the model contains <code class="classname">Package</code> instances the
		definition <code class="methodname">Root FOR Package</code> will be called for
		these instances. This is polymorphism at work! When the package contains
		subpackages, the definition is called recursively.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="umlclassic_create_template"></a>Creating a template for JavaBeans</h2></div></div></div><p>As we want to create JavaBean style classes from the entities in our
		model, we now want to create the template file for this. Create a new
		folder java within the folder <code class="filename">templates</code> create the
		file <code class="filename">JavaBean.xpt</code> there.</p><p>For a first step, this template will simply create a file with the
		name of the class.</p><pre class="programlisting">&laquo;IMPORT org::openarchitectureware::meta::uml::classifier&raquo;

&laquo;DEFINE BeanClass FOR Class&raquo;
	 &laquo;FILE NameS+".java"&raquo;
			public class &laquo;Name&raquo; {
			}
	 &laquo;ENDFILE&raquo;
&laquo;ENDDEFINE&raquo;</pre><p>Note, that we have named the definition
		<code class="methodname">BeanClass</code> and it is defined for elements of type
		<code class="classname">Class</code>. So, this template will not only fit for
		elements of type <code class="classname">Entity</code>, but can be used for any
		class.</p><p>In the <code class="varname">FILE</code> statement, we access the name of the
		current element by property <code class="methodname">NameS</code>. This is
		specific to the oAW classic metamodel. The property
		<code class="methodname">NameS</code> returns the name of the element as String.
		The property <code class="methodname">Name</code> itself is of type
		<code class="classname">Object</code> for backward compatibility. But in templates
		we usually want the name as a String object.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="umlclassic_calling_javabean_template"></a>Calling the <code class="methodname">JavaBean</code> template from
		<code class="filename">Root.xpt</code></h2></div></div></div><p>By now, this template is not called. We have to extend the
		<code class="filename">Root.xpt</code> template file. Add a definition
		<code class="methodname">Root</code> defined for <code class="classname">Entity</code>.
		We also have to add a new <code class="varname">IMPORT</code>, so that oAW can
		resolve <code class="classname">Entity</code>.</p><pre class="programlisting">&laquo;IMPORT oaw4::demo::classic::uml::meta&raquo;

...

&laquo;DEFINE Root FOR Entity&raquo;
&laquo;EXPAND java::JavaBean::BeanClass&raquo;
&laquo;ENDDEFINE&raquo;</pre><p>As you remember, while looping through the model for each element in
		the model tree a definition called <code class="methodname">Root</code> is
		called. Before adding this, we had a definition for Packages, Models, and
		all other objects. Now, when evaluating elements of type
		<code class="classname">Entity</code> this definition matches. In this definition,
		we call the definition named <code class="methodname">BeanClass</code> from the
		template file <code class="filename">JavaBean.xpt</code>. As the template
		<code class="filename">JavaBean.xpt</code> is defined in the package
		<code class="filename">java</code>, we also have to qualifiy this namespace. As an
		alternative, we could import the namespace <code class="filename">java</code>. The
		definition is (implicitely) called for the current element, which is of
		course an <code class="classname">Entity</code>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="umlclassic_first_generated_code"></a>The first generated code</h2></div></div></div><p>Run the generator again (as a shortcut you could type <span><strong class="keycap">Ctrl</strong></span>+<span><strong class="keycap">F11</strong></span>). Now, your project should contain the folder
		<code class="filename">src-gen</code>, which contains four files:
		<code class="filename">Author.java</code>, <code class="filename">Book.java</code>,
		<code class="filename">Copy.java</code> and
		<code class="filename">Library.java</code>.</p><p>Open <code class="filename">Author.java</code>. It does only contain the
		class definition, since the template was that simple.</p><pre class="programlisting">public class Author {
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="umlclassic_property_declaration"></a>Defining property declarations and accessor methods</h2></div></div></div><p>Now, we want to extend the JavaBean template to create instance
		variables, property getters and setters. Generating declarations for
		instance variables as well as their getter and setter methods is a very
		recurring task for attributes, so we want this in a central template
		file.</p><p>Create the file <code class="filename">Attribute.xpt</code> in folder
		<code class="filename">java</code>.</p><pre class="programlisting">&laquo;IMPORT org::openarchitectureware::meta::uml::classifier&raquo;

&laquo;DEFINE PropertyDeclaration FOR Attribute&raquo;
private &laquo;Type.NameS&raquo; &laquo;NameS&raquo;;
&laquo;ENDDEFINE&raquo;

&laquo;DEFINE Getter FOR Attribute&raquo;
public &laquo;Type.NameS&raquo; get&laquo;NameS.toFirstUpper()&raquo; () {
	 return this.&laquo;NameS&raquo;;
}
&laquo;ENDDEFINE&raquo;

&laquo;DEFINE Setter FOR Attribute&raquo;
public void set&laquo;NameS.toFirstUpper()&raquo; (&laquo;Type.NameS&raquo; &laquo;NameS&raquo;) {
	 this.&laquo;NameS&raquo; = &laquo;NameS&raquo;;
}
&laquo;ENDDEFINE&raquo;</pre><p>Of course, we also have to call these templates from our
		<code class="methodname">JavaBean</code> template. We want to call the templates
		<code class="methodname">PropertyDeclaration</code>,
		<code class="methodname">Getter</code> and <code class="methodname">Setter</code> for
		each attribute a class has. So, open your
		<code class="filename">JavaBean.xpt</code> template and extend it like
		follows:</p><pre class="programlisting">&laquo;IMPORT org::openarchitectureware::meta::uml::classifier&raquo;

&laquo;DEFINE BeanClass FOR Class&raquo;
&laquo;FILE NameS+".java"&raquo;
public class &laquo;Name&raquo; {
	 &laquo;EXPAND Attribute::PropertyDeclaration FOREACH Attribute&raquo;
	 &laquo;EXPAND Attribute::Getter FOREACH Attribute&raquo;
	 &laquo;EXPAND Attribute::Setter FOREACH Attribute&raquo;
}
&laquo;ENDFILE&raquo;
&laquo;ENDDEFINE&raquo;</pre><p>Once again, run the generator. Now, your generated files have
		properties!</p><pre class="programlisting">public class Author {
	 private String id;
	 private String name;

	 public String getId() {
			return this.id;
	 }

	 public String getName() {
			return this.name;
	 }

	 public void setId(String id) {
			this.id = id;
	 }

	 public void setName(String name) {
			this.name = name;
	 }
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="umlclassic_using_extensions"></a>Using Extensions</h2></div></div></div><p>A very powerful feature of openArchitectureWare 4 are
		extensions. With extensions the <span class="emphasis"><em>Xpand</em></span> template engine
		can be extended with functions without the need to modify the metamodel.<sup>[<a name="d0e11754" href="#ftn.d0e11754">9</a>]</sup> A very common use of extensions are the use of naming
		conventions, navigation, computation of package, path and filenames for
		artifacts etc.</p><p>openArchitectureWare extensions are declared in files ending with
		<code class="filename">.ext</code>. The declaration of extension functions can be
		by means of oAW expressions or by calling Java functions. The latter have
		to be declared <code class="code">public</code> and <code class="code">static</code>.</p><p>We will not cover the syntax of expressions very deep, so if you are
		interested to get more information look at the reference core reference
		chapters <span class="emphasis"><em><a href="core_reference.html#Xtend_language" title="Xtend">Xtend</a></em></span> and
		<span class="emphasis"><em><a href="core_reference.html#r10_expressions_language" title="Expressions">Expressions</a></em></span>. Also, in
		the other tutorials you can see more examples for the usage of
		expressions.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="umlclassic_declaring_functions"></a>Declaring functions with the <span class="emphasis"><em>Xtend</em></span>
			language</h3></div></div></div><p>For our example, we want to use extensions to introduce some
			naming conventions for instance variables, parameters, and the
			computation of the package and path for classes.</p><p>Now, create a file <code class="filename">NamingConventions.ext</code> in
			the <code class="filename">templates/java</code> folder. In this extension we
			declare some functions that are helpful for name conversions:<sup>[<a name="d0e11793" href="#ftn.d0e11793">10</a>]</sup></p><pre class="programlisting">import org::openarchitectureware::meta::uml;
import org::openarchitectureware::meta::uml::classifier;

String asParameter (ModelElement elem) :
	 "p"+elem.NameS.toFirstUpper();

String asSetter (ModelElement elem) :
	 "set"+elem.NameS.toFirstUpper();

String asGetter (ModelElement elem) :
	 "get"+elem.NameS.toFirstUpper();

String asInstanceVar (ModelElement elem) :
	 elem.NameS.toFirstLower();</pre><p>In extension files, import statements for used types are
			necessary, too. The function declarations are single-lined and can use
			any expressions, calls of other extension functions included.</p><p>Open <code class="filename">Attribute.xpt</code> and make use of these
			functions. In template files, the usage of extensions must be declared
			by the <code class="methodname">&laquo;EXTENSION&raquo;</code> keyword. The modified
			template file will look like this:</p><pre class="programlisting">&laquo;IMPORT org::openarchitectureware::meta::uml::classifier&raquo;
&laquo;EXTENSION java::NamingConventions&raquo;

&laquo;DEFINE PropertyDeclaration FOR Attribute&raquo;
	 private &laquo;Type.NameS&raquo; &laquo;asInstanceVar()&raquo;;
&laquo;ENDDEFINE&raquo;

&laquo;DEFINE Getter FOR Attribute&raquo;
	 public &laquo;Type.NameS&raquo; &laquo;asGetter()&raquo; () {
			return this.&laquo;asInstanceVar()&raquo;;
	 }
&laquo;ENDDEFINE&raquo;

&laquo;DEFINE Setter FOR Attribute&raquo;
public void &laquo;asSetter()&raquo; (&laquo;Type.NameS&raquo; &laquo;asParameter()&raquo;) {
	this.&laquo;asInstanceVar()&raquo; = &laquo;asParameter()&raquo;;
}
&laquo;ENDDEFINE&raquo;</pre><p>Run the generator and open <code class="filename">Author.java</code>. The
			file looks almost the same, since the replacements for instance
			variables, getter and setter method names are equivalent. The only
			difference are the parameters for setter methods. They are now prefixed
			with the character <code class="varname">p</code>.</p><pre class="programlisting">public void setId(String pId) {
	 this.id = pId;
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="umlclassic_calling_java_functions"></a>Calling Java functions as extensions</h3></div></div></div><p>More complex computations are often easier and more understandable
			by means of the Java programming language. So, the
			<span class="emphasis"><em>Xtend</em></span> language allows to define functions by
			referencing a Java function. The methods that should be called, must be
			declared <code class="methodname">public static</code>.</p><p>In our example, we miss the declaration of packages, and files are
			written into the root directory. We now want to declare some functions
			that help us to compute the full package name of classes, their
			corresponding path and the fully qualified name.</p><p>Create a new package
			<code class="classname">oaw4.demo.classic.uml.extend</code> and a class
			<code class="classname">ClassUtil</code>. In this class we define a function
			<code class="methodname">getPackageName()</code> that computes the full package
			of a Class (remember that we operate on the class of the metamodel named
			<code class="classname">(org.openarchitectureware.meta.uml.classifier.)Class</code>,
			not <code class="classname">java.lang.Class</code>).</p><pre class="programlisting">package oaw4.demo.classic.uml.extend;

import org.openarchitectureware.meta.uml.classifier.Class;
import org.openarchitectureware.meta.uml.classifier.Package;

public class ClassUtil {
	 public static String getPackageName (Class cls) {
			String result = "";
			for (Package pck=cls.Package(); pck!=null; pck=pck.SuperPackage()) {
				 result = pck.NameS() + (result.length()&gt;0 ? "."+result : "");
			}
			return result;
	 }
}</pre><p>We declare this function in
			<code class="filename">NamingConventions.ext</code> and two more functions that
			use it. Add these function declarations:</p><pre class="programlisting">String packageName (Class cls) :
	 JAVA oaw4.demo.classic.uml.extend.ClassUtil
	 .getPackageName(org.openarchitectureware.meta.uml.classifier.Class);

String packagePath (Class cls) :
	 packageName(cls).replaceAll("\\.", "/");

String fqn (Class cls) :
	 packageName(cls).length&gt;0 ? packageName(cls)+"."+cls.NameS : cls.NameS;</pre><p>The additional functions are used to compute the path to files
			based on a class and to get the full qualified name of a class. We want
			to make use of these functions to declare the package, compute the
			desired file path and to extend from the superclass, if a class has one
			(in our example model this is not the case yet). If no superclass
			exists, the Bean class should declare to implement the
			<code class="classname">Serializable</code> interface.</p><p>Open the <code class="filename">JavaBean.xpt</code> template file and
			modify it like follows:</p><pre class="programlisting">&laquo;IMPORT org::openarchitectureware::meta::uml::classifier&raquo;
&laquo;IMPORT java&raquo;
&laquo;EXTENSION java::NamingConventions&raquo;

&laquo;DEFINE BeanClass FOR Class&raquo;
&laquo;FILE packagePath()+"/"+NameS+".java"&raquo;
package &laquo;packageName()&raquo;;
public class &laquo;Name&raquo;
	 &laquo;IF hasSuperClass&raquo;extends &laquo;SuperClass.fqn()&raquo; &laquo;ENDIF&raquo;
	 implements java.io.Serializable {

...</pre><p>Once again, run the generator and refresh your
			<code class="filename">src-gen</code> folder. Now, the classes are generated in
			the expected directory structure:</p><div class="mediaobject"><img src="images/55_umlClassicExample/08_projectstructure.jpg"></div><p>The generated classes now contain the correct
			<code class="methodname">package</code> statement:</p><pre class="programlisting">package oaw4.demo.classic.uml.entity;

public class Author implements java.io.Serializable {
	 ...
</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="umlclassic_associations"></a>Working with associations</h2></div></div></div><p>In the model, we have defined some associations of different kind.
		In the next step, we evaluate these associations and create references,
		accessor methods and modification methods. As you can see, an m:n
		association between <code class="classname">Author</code> and
		<code class="classname">Book</code> exists. There also exists an association from
		<code class="classname">Library</code> to <code class="classname">Copy</code> with the
		multiplicity 1:n. The association from <code class="classname">Book</code> to
		<code class="classname">Copy</code> is not navigable. These associations must be
		handled differently.</p><p>Ordinary associations in UML consist of three elements: Two
		<span class="emphasis"><em>association ends</em></span> and one
		<span class="emphasis"><em>association</em></span> containing them. From the view of a
		class, a referenced class is at the <span class="emphasis"><em>opposite</em></span> end.
		Normally it must be considered whether the association, i.e. the opposite
		association end, to the referenced class is navigable.</p><div class="mediaobject"><img src="images/55_umlClassicExample/10_association.jpg"></div><p>Also, the templates for associations between classes are very
		common, so we define them in a central template file
		<code class="filename">Association.xpt</code> in the
		<code class="filename">templates/java</code> folder.</p><p>We want to keep the usage of the association template for the
		calling class template simple and hide this complex stuff about
		association ends. So, we define simple entry points for
		<code class="classname">Class</code> elements. We also make use of further
		extensions to facilitate template development.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="umlclassic_assoc_extensions"></a>Association Extensions</h3></div></div></div><p>The extensions for functions used for associations are put into a
			separate file. Create the file
			<code class="filename">templates/java/Associations.ext</code> with this
			content:</p><pre class="programlisting">import org::openarchitectureware::meta::uml::classifier;
extension java::NamingConventions;

String fqn (AssociationEnd ae) :
	 !ae.isMultiple ? ae.Class.fqn() : "java.util.Collection&lt;"+ae.Class.fqn()+"&gt;";

String iterator (AssociationEnd ae) : "java.util.Iterator&lt;"+ae.Class.fqn()+"&gt;";
</pre><p>As you can see, we will create Java 5 style collections for
			to-many associations. If you do not want to use generics, you could
			easily replace or modify the extension file and all associations will
			change to your style.</p><p>We see in this extension file, that other extensions can be
			referenced using the <code class="methodname">extension</code> keyword. In this
			case, we need the function <code class="methodname">fqn()</code> that was
			defined for classes. For associations, another function
			<code class="methodname">fqn()</code> is defined, but now for
			<code class="classname">AssociationEnd</code>s. For to-one associations, the
			fully qualified name of the associated class is returned, for to-many
			references, we return a generic collection for that class. In the
			template code, classes and association ends will both use the
			<code class="methodname">fqn()</code> function to print out the referenced
			type.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="umlclassic_template_for_association"></a>Writing a template for associations</h3></div></div></div><p>Now, it is time to write the template for associations. Create the
			file <code class="filename">Association.xpt</code>. Now fill in the content. We
			will explain some statements right after.</p><pre class="programlisting">&laquo;IMPORT org::openarchitectureware::meta::uml::classifier&raquo;
&laquo;EXTENSION java::NamingConventions&raquo;
&laquo;EXTENSION java::Associations&raquo;

&laquo;DEFINE ReferenceVariables FOR Class&raquo;
	 &laquo;FOREACH AssociationEnd.Opposite.select(ae|ae.isNavigable) AS ae&raquo;
			private &laquo;ae.fqn()&raquo; &laquo;ae.asInstanceVar()&raquo;;
	 &laquo;ENDFOREACH&raquo;
&laquo;ENDDEFINE&raquo;

&laquo;DEFINE AccessorMethods FOR Class&raquo;
	 &laquo;EXPAND ToOneAccessorMethods FOREACH
			AssociationEnd.Opposite.select(ae|!ae.isMultiple &amp;&amp; ae.isNavigable)&raquo;
	 &laquo;EXPAND ToManyAccessorMethods FOREACH
			AssociationEnd.Opposite.select(ae|ae.isMultiple &amp;&amp; ae.isNavigable)&raquo;
&laquo;ENDDEFINE&raquo;

&laquo;DEFINE ToOneAccessorMethods FOR AssociationEnd&raquo;
	 public void &laquo;asSetter()&raquo; (&laquo;Class.fqn()&raquo; &laquo;asParameter()&raquo;) {
			this.&laquo;asInstanceVar()&raquo; = &laquo;asParameter()&raquo;;
	 }

	 public &laquo;Class.fqn()&raquo; &laquo;asGetter()&raquo; () {
			return this.&laquo;asInstanceVar()&raquo;;
	 }
&laquo;ENDDEFINE&raquo;

&laquo;DEFINE ToManyAccessorMethods FOR AssociationEnd&raquo;
	 public void add&laquo;NameS.toFirstUpper()&raquo; (&laquo;Class.fqn()&raquo; &laquo;asParameter()&raquo;) {
			this.&laquo;asInstanceVar()&raquo;.add(&laquo;asParameter()&raquo;);
	 }

	 public void remove&laquo;NameS.toFirstUpper()&raquo; (&laquo;Class.fqn()&raquo; &laquo;asParameter()&raquo;) {
			this.&laquo;asInstanceVar()&raquo;.remove(&laquo;asParameter()&raquo;);
	 }

	 public &laquo;iterator()&raquo; &laquo;asGetter()&raquo; () {
			return this.&laquo;asInstanceVar()&raquo;.iterator();
	 }
&laquo;ENDDEFINE&raquo;</pre><p>At first, we see that this template uses both extensions,
			<code class="filename">NamingConventions</code> and
			<code class="filename">Associations</code>.</p><p>Next, a template <code class="methodname">ReferenceVariables</code> is
			declared. The template makes use of a <code class="methodname">FOREACH</code>
			loop of a different kind than we saw before. One more specific thing
			here is the statement</p><pre class="programlisting">&laquo;FOREACH AssociationEnd.Opposite.select(ae|ae.isNavigable) ...</pre><p>This returns all <span class="emphasis"><em>navigable</em></span> opposite end of
			each association end a class has.</p><p>The body of the loop declares a reference variable for an
			association. For both alternatives (to-one and to-many), the function
			<code class="methodname">fqn()</code> (the one defined for association ends) is
			called to determine the right type. In our example, this should result
			in the following both declarations:</p><pre class="programlisting">// to-one association (Copy.java)
private oaw4.demo.classic.uml.entity.Library owner;

// to-many association (Author.java)
private java.util.Collection&lt;oaw4.demo.classic.uml.entity.Book&gt; writtenBook;</pre><p>Both types are now expressed by this statement &#8211; simple, isn't
			it?</p><pre class="programlisting">private &laquo;ae.fqn()&raquo; &laquo;ae.asInstanceVar()&raquo;;</pre><p>The next template definition is also interesting. The definition
			<code class="methodname">AccessorMethods FOR Class</code> dispatches to the
			definitions <code class="methodname">ToOneAccessorMethods</code> or
			<code class="methodname">ToManyAccessorMethods</code>, depending on the
			cardinality of the association. To distinguish both types, we make use
			of the select expression which is defined for expression. The
			statement</p><pre class="programlisting">&laquo;EXPAND ToOneAccessorMethods FOREACH
	 AssociationEnd.Opposite.select(ae|!ae.isMultiple &amp;&amp; ae.isNavigable)&raquo;</pre><p>means that the definition
			<code class="methodname">ToOneAccessorMethods</code> should be expanded for
			each opposite association end which is not to-many and navigable. So for
			unnavigable associations no accessor method will be created.</p><p>The definitions for the accessor methods have nothing new, so we
			do not explain them in detail now.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="umlclassic_extending_javabeans_template"></a>Extending the JavaBeans template</h3></div></div></div><p>Now, we want to use the new templates from the JavaBeans template
			so that the classes get instance variables for referenced classes and
			appropriate accessor methods. Modify the template file
			<code class="filename">JavaBeans.xpt</code> by adding these two statements to the
			class definition:</p><pre class="programlisting">public class &laquo;Name&raquo; &laquo;IF hasSuperClass&raquo;extends &laquo;SuperClass.fqn()&raquo; &laquo;ENDIF&raquo;{
	 &laquo;EXPAND Attribute::PropertyDeclaration FOREACH Attribute&raquo;
	 &laquo;EXPAND Attribute::Getter FOREACH Attribute&raquo;
	 &laquo;EXPAND Attribute::Setter FOREACH Attribute&raquo;
	 &laquo;EXPAND Association::ReferenceVariables&raquo;
	 &laquo;EXPAND Association::AccessorMethods&raquo;
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="umlclassic_assoc_genresult"></a>Generator result</h3></div></div></div><p>Run the generator again. After successful generation, open
			<code class="filename">Book.java</code>. This file should have the following
			contents:</p><pre class="programlisting">package oaw4.demo.classic.uml.entity;

public class Book implements java.io.Serializable {
	 private String isbn;
	 private String title;
	 private java.util.Collection&lt;oaw4.demo.classic.uml.entity.Author&gt; author;

	 public String getIsbn () {
			return this.isbn;
	 }

	 public String getTitle () {
			return this.title;
	 }

	 public void setIsbn (String pIsbn) {
			this.isbn = pIsbn;
	 }

	 public void setTitle (String pTitle) {
			this.title = pTitle;
	 }

	 public void addAuthor (oaw4.demo.classic.uml.entity.Author pAuthor) {
			this.author.add(pAuthor);
	 }

	 public void removeAuthor (oaw4.demo.classic.uml.entity.Author pAuthor) {
			this.author.remove(pAuthor);
	 }

	 public java.util.Iterator&lt;oaw4.demo.classic.uml.entity.Author&gt; getAuthor () {
			return this.author.iterator();
	 }
}</pre><p>In this file, we have a to-many association named
			<code class="varname">author</code> to entity <code class="classname">Author</code>. No
			code exists for the association to the <code class="classname">Copy</code>
			class, since this association is not navigable.</p><p>An example for to-one associations can be seen in the
			<code class="filename">Copy</code> class:</p><pre class="programlisting">public class Copy implements java.io.Serializable {
	 ...
	 private oaw4.demo.classic.uml.entity.Library owner;
	 ...
	 public void setOwner (oaw4.demo.classic.uml.entity.Library pOwner) {
			this.owner = pOwner;
	 }

	 public oaw4.demo.classic.uml.entity.Library getOwner () {
			return this.owner;
	 }
	 ...
}</pre><p>The template code is really small, but now you could only have to
			model classes and their associations and you get the right JavaBeans
			code from the model. Our JavaBeans template is not specific for
			entities, you could use it to generate JavaBeans code for just any
			modelled class. But we only call this template for classes stereotyped
			with <code class="classname">&lt;&lt;Entity&gt;&gt;</code> for now. You remember
			that the model contains another class <code class="classname">&lt;&lt;DAO&gt;&gt;
			LibraryDAO</code> for which no code is generated yet.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="umlclassic_constraint_checking"></a>Constraint Checking</h2></div></div></div><p>It is very important that a generator produces correct output.
		Therefore, the input information must be valid, i.e. the model must be
		consistent. To prove this, the metamodel is enriched by constraints that
		check the consistence of the model.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="umlclassic_alternatives_checking"></a>Alternatives for implementing constraints</h3></div></div></div><p>Constraints can be provided in three different ways: </p><div class="itemizedlist"><ul type="disc"><li>
						 Overriding the

						<code class="methodname">checkConstraints()</code>

						 method of the metaclasses.

						<p>The <code class="methodname">checkConstraints()</code> method is
						only available for metaclasses based on the "classic" metamodel.
						It is not recommended to use this alternative. This alternative is
						for backward compatibility; in oAW3 metaclasses usually used this
						method to check model constraints.</p></li><li>
						 Using the new

						<span class="emphasis"><em>Check</em></span>

						 language.

						<p>oAW 4 has a new language named <span class="emphasis"><em>Check</em></span>
						that can be used to check model constraints. In this example, we
						will focus on this method. You may want to read the chapter
						<span class="emphasis"><em>
								<a href="core_reference.html#Check_language" title="Check">Check language</a>
							</em></span> in the core reference for more information.</p></li></ul></div><p>We want to implement constraint checks by using the
			<span class="emphasis"><em>Check</em></span> language. The syntax for check files is
			similar to those for Extensions, as it uses also the oAW Expressions
			framework. Check files have the file extension <code class="filename">.chk</code>
			and have be on the classpath in order to be found.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="umlclassic_constraints_to_implement"></a>Constraints to implement in the example</h3></div></div></div><p>In our example, we want to implement the following constraint:
			</p><div class="orderedlist"><ol type="1"><li>
						 Each navigable association end must have a role name.
					</li><li>
						 Unnavigable association ends should have no role name.
					</li></ol></div><p>Constraint 1 must be fulfilled, otherwise an error message should
			be printed and the generation process should not be started. If
			constraint 2 is not fulfilled a warn message should be printed, but the
			generation process should not be stopped.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="umlclassic_creating_check_file"></a>Creating the Check file</h3></div></div></div><p>As the constraints that should be implemented are specific for
			associations, the check file should be named
			<code class="filename">AssociationChecks.chk</code>. Create this file in
			<code class="filename">templates/java</code>.</p><pre class="programlisting">import org::openarchitectureware::meta::uml::classifier;

context AssociationEnd ERROR Class.NameS+"-&gt;"+Opposite.Class.NameS+":
	 Navigable association ends must have a role name" :
	 isNavigable ? !isUnnamed : true;

context AssociationEnd WARNING Class.NameS+"-&gt;"+Opposite.Class.NameS+":
	 Not navigable association ends should have no role name":
	 isNavigable ? true : isUnnamed;</pre><p>The syntax is rather simple. Both constraints should be checked
			for the metaclass <code class="classname">AssociationEnd</code>, so the
			appropriate namespace has to be imported. The expression following the
			colon is the constraint. If it is not fulfilled, the message is printed.
			When error messages are printed, the workflow will be
			interrupted.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="umlclassic_integrating_check"></a>Checking the model</h3></div></div></div><p>To execute the constraint checks, the generator workflow has to be
			extended. The constraint check is configured by a workflow component
			<code class="classname">CheckComponent</code>. Insert this code into
			<code class="filename">workflow.oaw</code>, right between the cartridge
			<code class="filename">classicinit.oaw</code> and the
			<code class="classname">dirCleaner</code> component.</p><pre class="programlisting">&lt;component class="org.openarchitectureware.check.CheckComponent"&gt;
	 &lt;metaModel class="org.openarchitectureware.type.impl.java.JavaMetaModel"&gt;
		 &lt;typeStrategy class="org.openarchitectureware.type.impl.oawclassic.OAWClassicStrategy"
			 convertPropertiesToLowerCase="false"/&gt;
	 &lt;/metaModel&gt;
	 &lt;checkFile value="java::AssociationChecks"/&gt;
	 &lt;expression value="me.getElements('ModelElement')"/&gt;
	 &lt;abortOnError value="true"/&gt;
&lt;/component&gt;</pre><p>Also, the constraint checker has to know which metamodel it should
			use. It is the same configuration as for the Generator
			component.<sup>[<a name="d0e12180" href="#ftn.d0e12180">11</a>]</sup>The <code class="varname">checkFile</code> property specifies the
			qualified name of the check file.</p><p>Finally, the <code class="varname">expression</code> property defines for
			which elements to constraints should be applied. In our case, we select
			<span class="emphasis"><em>all</em></span> elements in the
			<code class="classname">MetaEnvironment</code>. However, for our special case it
			would be satisfactory to select only all elements of type
			<code class="classname">AssociationEnd</code>. For larger projects, it could be
			of advantage to select the right subset of elements for improving
			performance.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="umlclassic_testing_constraints"></a>Testing the constraints</h3></div></div></div><p>Start the generator. The generator should run without complaining,
			because all constraints are fulfilled in the example model for
			now.</p><p>Now open the model; we will change the model in a way that both
			constraints are not fulfilled.</p><p>First, edit the association between <code class="classname">Book</code>
			and <code class="classname">Author</code>. Take the association end named
			<code class="varname">author</code> and remove the name. Set the
			<code class="varname">navigable</code> flag to <code class="varname">false</code> for the
			opposite end named <code class="varname">writtenBooks</code>.</p><p>Save the model and re-run the generator. The generator now
			produces the expected messages and stops execution, because there is one
			constraint error and one warning.</p><pre class="programlisting">4316 INFO  Starting: org.openarchitectureware.check.CheckComponent
4667 ERROR Workflow interrupted. Reason: Errors during validation.
4667 WARN  Book-&gt;Author: Not navigable association ends should have no role
					 name [&lt;&lt;AssociationEnd&gt;&gt; writtenBook]
4667 ERROR Author-&gt;Book: Navigable association ends must have a role name [&lt;&lt;AssociationEnd&gt;&gt; ] </pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="umlclassic_further_development"></a>Further development of this tutorial</h2></div></div></div><p>This tutorial is not finished. I plan to extend it in order to show
		more basic things about oAW usage. If you have any suggestions let me know
		them. Some features that will be handled in the future are: </p><div class="itemizedlist"><ul type="disc"><li>
					 Extending the metamodel manually
				</li><li>
					 Usage of MMUtil functions in metamodel classes
				</li><li>
					 Generating the metaclasses with the Metamodel Generator
				</li><li>
					 Demonstration of some oAW expression language features, e.g. collection filter, list operations
				</li></ul></div></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.d0e11754" href="#d0e11754">9</a>] </sup>With openArchitectureWare3 it was needed to code functionality
				of the metamodel in metaclasses</p></div><div class="footnote"><p><sup>[<a name="ftn.d0e11793" href="#d0e11793">10</a>] </sup>The functions in the Extension file could be defined for type
					<code class="classname">Attribute</code> instead of
					<code class="classname">ModelElement</code>, but we want to use these
					functions for other types later on, too.</p></div><div class="footnote"><p><sup>[<a name="ftn.d0e12180" href="#d0e12180">11</a>] </sup>It is possible to declare the used metamodel once and
					reference it the second time.</p></div></div></div></body></html>